---
title: Milvus
tags: 人工智能
toc: true
---

本文是阅读 [Milvus: A Purpose-Built Vector Data Management System](https://www.cs.purdue.edu/homes/csjgwang/pubs/SIGMOD21_Milvus.pdf) 论文的总结。

# 介绍

随着数据科学和 AI 的快速发展，深度学习模型需要将大量的非结构化数据转换为向量，用来做数据分析，比如产品推荐。现存的向量数据库在性能和功能性方面都已经不太符合当前深度学习大规模应用场景的需求。

为了解决向量检索的问题，出现了很多解决方案，比如用关系数据库来存储向量（即有一个列专门存储向量），但是它未对向量计算做特殊优化，检索效率比较低。后来逐渐出现了很多向量数据库，比如 chroma，faiss 等，但是他们也存在两个问题，第一个问题是不能横向扩展，因为他们的设计就是将向量全部存储在主内存中，无法存储在磁盘以及横向扩展到其他节点，第二个问题是检索能力有限，比如缺少按照属性过滤或者多向量同时检索。

此时 Milvus 出现了。

Milvus 具有如下特性：
* 基于 Facebook 开源的 Faiss 向量数据库，支持多种相似度检索算法，包括点积、余弦相似度、欧氏距离等；
* 基于 LSM（Log-Structured Merge Tree），支持内存和磁盘存储，同时也增强了数据写入性能（这是相对的来说的，因为 LSM 涉及磁盘操作，肯定没有直接操作内存块。由于 Milvus 提供了存储容量，突破内存限制，在涉及磁盘操作的情况下，LSM 可以增强磁盘写入性能）；
* 充分利用异构多核 CPU 和 GPU 的高效计算能力加速计算，支持 SIMD 向量计算；
* 支持根据属性过滤，比如在产品推荐中，可以根据一个图片向量来搜索价格小于 100 的商品；
* 可以横向扩展，支持多节点存储；
* 支持索引，包括基于量化的索引和基于图形的索引；

# 系统设计

Milvus 主要由三部分组成，分别是查询引擎、GPU计算引擎和存储引擎，如图-1所示。

![Milvus 系统架构](/images/milvus/milvus_system_arch.png)
 *图-1 Milvus 系统架构*

 ## 查询处理

 Milvus 存储的数据都是数值，不管是向量还是属性。它支持三种基本的查询类型，分别是：
 * 向量查询：也就是基本的向量相似度查询，它会返回用户相似度最高的前 k 个结果，k 是用户指定的；
 * 属性过滤：一个记录可以是由一个向量和多个属性组成的，当查询 k 个结果时可以加上属性过滤，比如要求价格小于 100 元；
 * 多向量查询：一个记录可以是由多个向量组成的，当查询 k 个记录时会根据多个向量的聚合函数来过滤结果，如果加权和大于 10；

 Milvus 支持以下相似度函数：
 * 欧氏距离
 * 点积
 * 余弦相似度
 * 汉明距离
 * Jaccard 相似度

 Milvus 提供了 Java、C++、Python、Go 等编程语言的 SDK，方便快速接入。

## 索引

Milvus 支持两种类型的索引，分别是基于量化的索引和基于图形的索引。

* 量化索引：包括 IVF_FLAT，IVF_SQ8，IVF_PQ；
* 图形索引：包括 HNSW 和 RNSG；

Milvus 高级抽象索引接口，以便扩展支持新出现的索引。

## 动态数据管理

Milvus 使用 LSM-tree 的设计思想来支持高效的新增（insertion）和删除（deletion）操作。新增数据先写入内存的 MemTable 中，当 MemTable 的大小超过设定的阈值后则将 MemTable 设置为不可变，然后将其作为一个块（Segment）写入磁盘。多个小块会合并得到一个大块，直到超过阈值后，块也就不再合并。这种分层合并策略与 LevelDB 非常相似，其实 LevelDB 中的 Level 就是指多级或者分层合并的意思。更新和删除操作也是作为一种特殊的 insertion 来完成的，先将更新或者删除操作写入  MemTable，当落盘写入到 Segment 后，会不断的合并，旧数据就会逐渐被新数据覆盖，从而完成 update 和 deletion 操作。注意，在 LSM-tree 中，deletion 比较特殊，它表示删除一个记录，这个删除标记在多次合并 Segment 中可能会一直存在，用来表示记录已经删除。

Milvus 支持快照隔离级别来保证读和写能共享一致的视图，不会相互干扰。

## 存储管理

前面提到向量检索 topK 行记录时，每行记录我们称之为实体（entity），相同类型的多个实体就组成了实体表（Entity Table），每一个实体也称之为行（row）。为了便于向量检索，Milvus 基于列式风格来存储实体表中的记录。

**向量存储**。对于只有一个向量的实体，Milvus 连续存储实体的向量，每个向量存储的长度都一样。对于一个包含多个向量的实体，Milvus 依然使用一列来存储，但是每种向量归类连续存储。比如有三个实体 A、B、C，每个实体包含两个向量 v<sub>1</sub> 和 v<sub>2</sub>，那么所有实体的 v<sub>1</sub> 向量存储在一起，所有实体的 v<sub>2</sub> 向量存储在一起，所以存储格式是 {A.v<sub>1</sub>, B.v<sub>1</sub>, C.v<sub>1</sub>, A.v<sub>2</sub>, B.v<sub>2</sub>, C.v<sub>2</sub>}。

**属性存储**。Milvus 将属性一列一列的存储，每一个属性列都是一个  `<key, value>` 对的数组，key 是属性的值，value 是行 ID。此外，在索引管理下的数据页，Milvus 创建跳跃指针（比如存储最大最小值）来加速范围查询和单行查询。

**Bufferpool**。类似 MySQL 的 buffer pool，常用的 Segment 会存储在内存中，当内存空间不足时通过 LRU 算法将不常用的 Segment 移除。

**多存储**。Milvus 不仅可以将数据存储在本地磁盘，还可以将数据存储在 S3、HDFS。这个特性让 Milvus 非常方便的部署在云平台。

**分布式**。Milvus 采用了现代分布式系统和云平台设计经验，实现了存储计算分离，共享存储，读写分离，一写多读。

# 异构计算

通过基于量化的索引来介绍 Milvus 的优化，因为它消耗更少的内存并且可以更快的创建索引来加速查询。

## 背景

首先介绍一下向量量化和基于量化的索引。向量量化的主要思想是应用量化器 z 将向量 v 映射到从码本 C 中选择的码字 z(v)。 K-means 聚类算法通常用于构造码本 C，其中每个码字是中心，z(v) 是最接近 v 的中心。图-2是由10个向量组成的 3 个集群，所以 z(v<sub>0</sub>), z(v<sub>1</sub>), z(v<sub>2</sub>), z(v<sub>3</sub>) 属于集群 c<sub>0</sub>。

![量化的例子](/images/milvus/milvus_vector_quantization.png)
*图-2 一个量化的例子*

基于量化的索引（比如 IVF_FLAT, IVF_SQ8, and IVF_PQ）使用两类量化器：粗粒度量化器和细粒度量化器。粗粒度量化器使用 K-means 聚类算法将向量划分称 k 个桶（bucket），而细粒度量化器编码每个桶中的向量。不同索引使用不同的细粒度量化器，比如 IVF_FLAT 使用最原始的向量表示方式，IVF_SQ8 是一种压缩向量表示法，它采用一维量化器将 4 字节的向量压缩成 1 字节。IVF_PQ 则使用点积量化将每个向量切分为多个子向量，然后在子空间中使用 K-means 算法。

向量检索包括两个步骤（假设查询 q）：
* 根据 q 和每个桶的中心的距离，找到 n<sub>probe</sub> 个最接近的桶，比如图-2中最接近 q 的两个桶是 c<sub>0</sub> 和 c<sub>1</sub>。参数 n<sub>probe</sub> 控制精确度和性能，精确度和性能是一个矛盾体，追求高精确度肯定会降低性能。当 n<sub>probe</sub> 的值越高时则精确度就越高，所以性能就比较差了。
* 使用不同的细粒度量化器在最接近的桶中检索向量，比如图-2中的索引是 IVF_FLAT 时，它会从两个桶中检索 v<sub>0</sub>-v<sub>6</sub>。

## 面向 CPU 的优化



## 面向 GPU 的优化

