---
title: Java后端开发 - MYSQL
date: 2018-10-13 08:15:36
tags: mysql
---



# 三范式

范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”，通俗地说就是一张数据表的表结构所符合的某种设计标准的级别。数据库范式分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。符合高一级范式的设计，必定符合低一级范式，例如符合2NF的关系模式，必定符合1NF。

**第一范式（1NF）指符合1NF的关系中的每个属性都不可再分**，1NF是所有关系型数据库的最基本要求。但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，需要更高级范式来解决这些问题。

**第二范式（2NF）指2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖**。

**码**的定义是关系中的某个属性或者某几个属性的组合，用于区分每个元组，设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为**候选码**，简称为**码**。在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**一张表中可以有超过一个码。包含在任何一个码中的属性称为主属性，除去主属性就是**非主属性**。**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y**。在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X **完全函数依赖**，记作 X F→ Y。假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y **部分函数依赖**于 X，记作 X P→ Y。假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （Y 不包含于 X，且 X 不函数依赖于 Y），那么我们就称 Z **传递函数依赖**于 X ，记作 X T→ Z。

根据2NF的定义，判断的依据实际上就是看数据表中**是否存在非主属性对于码的部分函数依赖**。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是：

第一步：找出数据表中所有的**码**。
第二步：根据第一步所得到的码，找出所有的**主属性**。
第三步：数据表中，除去所有的主属性，剩下的就都是**非主属性**了。
第四步：查看是否存在非主属性对码的**部分函数依赖**。

消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“，模式分解的方法不是唯一的。

**第三范式（3NF）** **3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖**，也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。

符合3NF要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF。



参考：[如何解释关系数据库的第一第二第三范式？](https://www.zhihu.com/question/24696366)

# 悲观锁和乐观锁

**悲观锁**指假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。

**乐观锁**指假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。在数据库中，乐观锁的实现方法是使用数据版本（version）记录机制，当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

参考：[MySQL 乐观锁与悲观锁](https://www.jianshu.com/p/f5ff017db62a)

# Innodb事务隔离级别

数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。

事务的ACID特征为原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持久性（ Durability ）。

* 原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行；

* 一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束；

* 隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行；

* 持久性：已被提交的事务对数据库的修改应该永久保存在数据库中。

Mysql的Innodb引擎支持事务，定义了4类隔离级别，分别是读取未提交，读取提交，可重复读，序列化。

* **Read Uncommitted（读取未提交）**

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

* **Read Committed（读取提交）**

一个事务只能看见已提交事务所做的改变。这种隔离级别解决了脏读的问题，但是存在不可重复读（Nonrepeatable Read）的问题，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

* **Repeatable Read（可重复读）**

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这种隔离级别解决了不可重复读的问题，但是在[SQL-92](https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt)的定义中还存在存在幻读 （Phantom Read），Innodb中不存在幻读。幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

* **Serializable（可串行化）**

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

不同隔离级别的读问题如下表：

| Isolation level  | Lost updates | Dirty reads | Non-repeatable reads | Phantoms    |
| ---------------- | ------------ | ----------- | -------------------- | ----------- |
| Read Uncommitted | don't occur  | may occur   | may occur            | may occur   |
| Read Committed   | don't occur  | don't occur | may occur            | may occur   |
| Repeatable Read  | don't occur  | don't occur | don't occur          | may occur   |
| Serializable     | don't occur  | don't occur | don't occur          | don't occur |

数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）。

加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。

解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

在可重复读的隔离级别中，Innodb使用MVCC解决幻读，原理是：Innodb为每一行添加3个额外的字段，分别是6字节的DB_TRX_ID（记录插入或者更新该行的事务ID）；1字节的删除标记位Deleted（当执行Deleted时，将该标记置为1）；7字节的DB_ROLL_PTR（用来记录修改前的行指针），当一个事物读取某一行时，mysql内部使用[ReadView](https://github.com/stltqhs/mysql-server/blob/5.7/storage/innobase/include/read0types.h)结构记录读取行的事务号，而且读取行的DB_TRX_ID不会大于本事务的事务ID。当其他事务修改该行时，会创建新的记录用来存储更改的数据，而由于readview的关系，当前事务不会读取到修改的数据。当执行delete操作时，mysql不会立即删除该行，而是将该行标记为Deleted。对于旧的行数据，mysql内部会检查是否存在其他事务正在读取或者已经读取该行，如果没有任何事务读取该行，则该行将在*purge*线程中清除。可以使用锁的方式使得事务总是读取最新行，这种方式称为“当前读”，与之对应的就称为“快照读”。对于普通的Select查询操作都是“快照读”，而Update，Delete，Select ... lock in share mode和Select ... for update则都是“当前读”。

参考：[MySQL（二）｜深入理解MySQL的四种隔离级别及加锁实现原理](https://www.jianshu.com/p/dab1c0ecbac0)，[数据库事务](https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1)，[Isolation](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29)，[InnoDB Multi-Versioning](https://dev.mysql.com/doc/refman/5.6/en/innodb-multi-versioning.html)

# Innodb索引

# Innodb锁

参考：[Understanding Innodb locks and deadlocks](https://www.percona.com/live/mysql-conference-2015/sites/default/files/slides/understandinginnodblocksanddeadlocks.pdf)

# mysql的存储引擎

# 优化

# Nosql