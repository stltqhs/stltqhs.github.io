<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Java后端开发 - 网络 | 海东青</title>
  <meta name="description" content="HTTPHTTP协议规范：  1996年的HTTP1.0的RFC1945 1999年的HTTP1.1的RFC2616 2015年的HTTP/2的RFC7540和RFC7541  HTTP1.0的问题HTTP协议的基本特点是“一来一回”，客户端发起一个TCP连接，在连接上面发一个HTTP Request到服务器，服务器返回一个HTTP Response，然后关闭连接。每个请求都要重复这样的操作，存在">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java后端开发 - 网络">
<meta property="og:url" content="https://stltqhs.github.io/2018/10/13/java-programmer-knowledge-network/index.html">
<meta property="og:site_name" content="海东青">
<meta property="og:description" content="HTTPHTTP协议规范：  1996年的HTTP1.0的RFC1945 1999年的HTTP1.1的RFC2616 2015年的HTTP/2的RFC7540和RFC7541  HTTP1.0的问题HTTP协议的基本特点是“一来一回”，客户端发起一个TCP连接，在连接上面发一个HTTP Request到服务器，服务器返回一个HTTP Response，然后关闭连接。每个请求都要重复这样的操作，存在">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://stltqhs.github.io/images/http_pipeline.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/rsa_bidirection.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/rsa_direction.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/rsa_mediator_attack.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/rsa_ca.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/rsa_tls_handshake.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/tcp_handshake.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/tcp_close.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/java_nio_abstract.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/reactor_single_thread.webp">
<meta property="og:image" content="https://stltqhs.github.io/images/reactor_multiple_thread.webp">
<meta property="og:image" content="https://stltqhs.github.io/images/reactor_master_slave.webp">
<meta property="og:image" content="https://stltqhs.github.io/images/network_io_1_n_m.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/tomcat_thread_model.jpg">
<meta property="og:updated_time" content="2023-09-04T00:20:24.363Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java后端开发 - 网络">
<meta name="twitter:description" content="HTTPHTTP协议规范：  1996年的HTTP1.0的RFC1945 1999年的HTTP1.1的RFC2616 2015年的HTTP/2的RFC7540和RFC7541  HTTP1.0的问题HTTP协议的基本特点是“一来一回”，客户端发起一个TCP连接，在连接上面发一个HTTP Request到服务器，服务器返回一个HTTP Response，然后关闭连接。每个请求都要重复这样的操作，存在">
<meta name="twitter:image" content="https://stltqhs.github.io/images/http_pipeline.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://stltqhs.github.io/2018/10/13/java-programmer-knowledge-network/index.html">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/stltqhs" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">海东青</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java 技术专家</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Guangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/">mq</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云原生/">云原生</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人工智能/">人工智能</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机体系结构/">计算机体系结构</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/NoSQL/" style="font-size: 13.33px;">NoSQL</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/mq/" style="font-size: 13px;">mq</a> <a href="/tags/云原生/" style="font-size: 13.33px;">云原生</a> <a href="/tags/人工智能/" style="font-size: 13px;">人工智能</a> <a href="/tags/大数据/" style="font-size: 13.67px;">大数据</a> <a href="/tags/算法/" style="font-size: 13px;">算法</a> <a href="/tags/网络/" style="font-size: 13.33px;">网络</a> <a href="/tags/计算机体系结构/" style="font-size: 13.33px;">计算机体系结构</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/09/Linux-kernel-about-network-second/" class="title">Linux 网络简说（下）</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-09T14:31:05.000Z" itemprop="datePublished">2023-09-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/09/Linux-kernel-about-network/" class="title">Linux 网络简说（上）</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-09T08:20:24.000Z" itemprop="datePublished">2023-09-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/08/Borg-Omega-and-Kubernates/" class="title">Borg, Omega, and Kubernates</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-08T06:40:38.000Z" itemprop="datePublished">2023-09-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/07/Borg/" class="title">Borg</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-07T05:13:17.000Z" itemprop="datePublished">2023-09-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/03/Milvus/" class="title">Milvus</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-03T09:18:33.000Z" itemprop="datePublished">2023-09-03</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP"><span class="toc-number">1.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-0的问题"><span class="toc-number">1.1.</span> <span class="toc-text">HTTP1.0的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-1"><span class="toc-number">1.2.</span> <span class="toc-text">HTTP1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#连接复用与Chunk机制"><span class="toc-number">1.2.1.</span> <span class="toc-text">连接复用与Chunk机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipeline与Head-of-line-Blocking问题"><span class="toc-number">1.2.2.</span> <span class="toc-text">Pipeline与Head-of-line Blocking问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2"><span class="toc-number">1.3.</span> <span class="toc-text">HTTP/2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#与HTTP1-1兼容"><span class="toc-number">1.3.1.</span> <span class="toc-text">与HTTP1.1兼容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二进制分帧"><span class="toc-number">1.3.2.</span> <span class="toc-text">二进制分帧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#头部压缩"><span class="toc-number">1.3.3.</span> <span class="toc-text">头部压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SSL-TLS"><span class="toc-number">2.</span> <span class="toc-text">SSL/TLS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP"><span class="toc-number">3.</span> <span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#解决不丢问题-ACK-重发"><span class="toc-number">3.1.</span> <span class="toc-text">解决不丢问题:ACK+重发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决不重复的问题"><span class="toc-number">3.2.</span> <span class="toc-text">解决不重复的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决时序错乱的问题"><span class="toc-number">3.3.</span> <span class="toc-text">解决时序错乱的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三次握手"><span class="toc-number">3.4.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四次挥手"><span class="toc-number">3.5.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#状态机"><span class="toc-number">3.6.</span> <span class="toc-text">状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC"><span class="toc-number">3.7.</span> <span class="toc-text">QUIC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP流量控制、拥塞控制"><span class="toc-number">4.</span> <span class="toc-text">TCP流量控制、拥塞控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络IO模型"><span class="toc-number">5.</span> <span class="toc-text">网络IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO多路复用"><span class="toc-number">5.1.</span> <span class="toc-text">IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#select-poll"><span class="toc-number">5.1.1.</span> <span class="toc-text">select/poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#epoll"><span class="toc-number">5.1.2.</span> <span class="toc-text">epoll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO"><span class="toc-number">5.1.3.</span> <span class="toc-text">NIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor模式"><span class="toc-number">5.2.</span> <span class="toc-text">Reactor模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proactor模式"><span class="toc-number">5.3.</span> <span class="toc-text">Proactor模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务器编程中的1-N-M模型"><span class="toc-number">5.4.</span> <span class="toc-text">服务器编程中的1+N+M模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat"><span class="toc-number">5.4.1.</span> <span class="toc-text">Tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nginx"><span class="toc-number">5.4.2.</span> <span class="toc-text">Nginx</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-java-programmer-knowledge-network" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      Java后端开发 - 网络
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2018/10/13/java-programmer-knowledge-network/" class="article-date">
	  <time datetime="2018-10-13T00:17:59.000Z" itemprop="datePublished">2018-10-13</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/java/">java</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2018/10/13/java-programmer-knowledge-network/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP协议规范：</p>
<ul>
<li>1996年的HTTP1.0的<a href="https://tools.ietf.org/html/rfc1945" target="_blank" rel="noopener">RFC1945</a></li>
<li>1999年的HTTP1.1的<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC2616</a></li>
<li>2015年的HTTP/2的<a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">RFC7540</a>和<a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener">RFC7541</a></li>
</ul>
<h2 id="HTTP1-0的问题"><a href="#HTTP1-0的问题" class="headerlink" title="HTTP1.0的问题"></a>HTTP1.0的问题</h2><p>HTTP协议的基本特点是“一来一回”，客户端发起一个TCP连接，在连接上面发一个HTTP Request到服务器，服务器返回一个HTTP Response，然后关闭连接。每个请求都要重复这样的操作，存在以下问题：</p>
<ul>
<li>频繁的连接建立与关闭造成的<strong>性能问题</strong>，该问题使用Keep-Alive机制解决</li>
<li>服务器推送问题，服务器无法在客户端没有请求的情况下主动向客户端推送消息</li>
</ul>
<h2 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h2><h3 id="连接复用与Chunk机制"><a href="#连接复用与Chunk机制" class="headerlink" title="连接复用与Chunk机制"></a>连接复用与Chunk机制</h3><p>HTTP1.1默认启用<code>Connection: Keep-Alive</code>属性来达到连接复用。HTTP1.0的<code>Content-Length</code>属性用来解决Keep-Alive启用时让客户端判断是否数据已经传输完毕，导致的问题是在动态语言生成的HTTP页面内容时，服务端需要在内存中渲染然后再计算长度，效率低。HTTP1.1的解决办法是使用<code>Transfer-Encoding: chunked</code>机制，数据分块传输。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">0B</span><br><span class="line">Hello World</span><br><span class="line">05</span><br><span class="line">number</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>分块传输时也需要告知每块的字节大小。</p>
<h3 id="Pipeline与Head-of-line-Blocking问题"><a href="#Pipeline与Head-of-line-Blocking问题" class="headerlink" title="Pipeline与Head-of-line Blocking问题"></a>Pipeline与Head-of-line Blocking问题</h3><p>在连接复用中，请求是串性执行，并发度不高。HTTP1.1引入Pipeline机制，在同一个TCP连接上，可以在一个请求发出后响应未发回来之前，发送下一个、再下一个请求，可提高请求的处理效率。然而，Piepline的请求-响应是先近先出，即响应第二个请求时必须发生在响应完第一个请求之后，如果第一个请求耗时长，则第二个请求将会阻塞，这种行为称为Head-of-line Blocking，即“队头阻塞”。由于“队头阻塞”，Pipeline机制一般被关闭状态。</p>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><h3 id="与HTTP1-1兼容"><a href="#与HTTP1-1兼容" class="headerlink" title="与HTTP1.1兼容"></a>与HTTP1.1兼容</h3><p>使用一个转换层SPDY（即HTTP/2）来兼容HTTP1.1协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| HTTP 1.1 |</span><br><span class="line">+----------+</span><br><span class="line">|  HTTP/2  |</span><br><span class="line">|  (SPDY)  |</span><br><span class="line">+----------+</span><br><span class="line">|    TCP   |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>二进制分帧是HTTP/2为了解决HTTP1.1的“队头阻塞”问题所设计的核心特征。原理是将一个请求的字符内容转换为二进制，并且分成多个帧来发送。这样一来，多个请求被切分后可乱序发送，接收响应时顺序也不确定，从HTTP协议层解决“对头阻塞”。但由于TCP是“先进先出”，它依然存在“队头阻塞”。要彻底解决“队头阻塞”就是不使用TCP，使用Google的QUIC。</p>
<p>Pipeline和HTTP/2请求响应：</p>
<p><img src="/images/http_pipeline.jpg" alt="Pipeline和HTTP/2请求响应" title="Pipeline和HTTP/2请求响应"></p>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>HTTP/2使用HPACK协议和对应的算法对HTTP头部压缩。</p>
<h1 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h1><p>明文传输和对称加密传输都不安全，需要使用RSA非对称加密传输数据。RSA分为公钥和私钥，服务端存储私钥，而公钥存储在客户端。为了防止数据被篡改，需要签名，为了防止中间人攻击，需要CA数字证书。</p>
<p>双向非对称加密：</p>
<p><img src="/images/rsa_bidirection.jpg" alt="双向非对称加密" title="双向非对称加密"></p>
<p>单向非对称加密：</p>
<p><img src="/images/rsa_direction.jpg" alt="单向非对称加密" title="单向非对称加密"></p>
<p>中间人攻击：</p>
<p><img src="/images/rsa_mediator_attack.jpg" alt="中间人攻击" title="中间人攻击"></p>
<p>数字证书和CA</p>
<p><img src="/images/rsa_ca.jpg" alt="数字证书和CA" title="数字证书和CA"></p>
<p>SSL/TLS四次握手：</p>
<p><img src="/images/rsa_tls_handshake.jpg" alt="SSL/TLS四次握手" title="SSL/TLS四次握手"></p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP协议规范是<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a>。</p>
<p>TCP通过消息顺序编号+客户单重发+服务端顺序ACK实现了客户端到服务器的数据包的不重、不漏、时序不乱。</p>
<h2 id="解决不丢问题-ACK-重发"><a href="#解决不丢问题-ACK-重发" class="headerlink" title="解决不丢问题:ACK+重发"></a>解决不丢问题:ACK+重发</h2><p>网络的不稳定造成丢包是肯定发生的，解决不丢只有<strong>重发</strong>。服务端每收到一个包，都要对客户端进行确认，如果客户端在超时时间内未收到ACK，则重发。客户端发送时需要对每个数据包编号，号码从小到大单调递增。当服务端收到数据包确认时回复ACK=n表示所有小于或等于n的数据包都已经收到了，可以不用逐一回复。</p>
<h2 id="解决不重复的问题"><a href="#解决不重复的问题" class="headerlink" title="解决不重复的问题"></a>解决不重复的问题</h2><p>由于服务端回复确认信息时是<strong>顺序ACK</strong>，比如回复ACK=6表示小于或等于6的数据包都已经收到，下次收到5的数据包时，能够判断5这个数据包已经重复。</p>
<h2 id="解决时序错乱的问题"><a href="#解决时序错乱的问题" class="headerlink" title="解决时序错乱的问题"></a>解决时序错乱的问题</h2><p>假设服务队收到了数据包1、2、3，回复客户端ACK=3，之后收到5、6、7，而数据包4迟迟没有收到，此时服务端会将数据包5、6、7暂存，此时不回复ACK，等待数据包4的到来。如果超时后客户端仍然没有收到ACK，则重发数据包4、5、6、7。当客户端收到数据包4时，就可以回复ACK=7，同时数据包5、6、7重复，丢弃即可。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP建立连接的过程：</p>
<p><img src="/images/tcp_handshake.jpg" alt="TCP三次握手" title="TCP三次握手"></p>
<ul>
<li>图中的ACK的意思和前面所讲的稍微有些差异：前文中的ACK=7表示小于或等于7的数据包都收到了；这里的ACK=x+1表示小于或等于x的数据包都收到了，接下来要接收x+1的数据包</li>
<li>seq=x表示发出去的数据包编号是x，因为TCP是全双工通信，为了优化传输，将seq=y和ACK=x+1合并一个数据包发出去。</li>
</ul>
<p>为什么需要三次握手？由于网络的两将军问题<a href="https://en.wikipedia.org/wiki/Two_Generals%27_Problem" target="_blank" rel="noopener"> [1] </a>，使用三次握手恰好可以保证客户端和服务端对自己的发送、接收能力做了一次确认，保证了自己发送的数据对方可以接收。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>TCP关闭连接的过程：</p>
<p><img src="/images/tcp_close.jpg" alt="TCP四次挥手" title="TCP四次挥手"></p>
<ul>
<li>为什么需要四次挥手？因为TCP是全双工通信，第一次和第二次，TCP连接还处于Half-Close状态，需要等到第三次和第四次连接才会处于完全的CLOSE状态</li>
<li>为什么服务端收到客户端的FIN请求后，需要分两次发ACK和FIN？服务端需要通知上层应用做清理工作，同时因为下一个原因</li>
<li>为什么需要一起进入TIME_WAIT状态？由于网络数据包传输会有延时，当双方都进入CLOSE状态时，仍然可能有数据包还在网络上“闲逛”，此时如果收到了这些闲逛的数据包，丢掉即可，但是问题是连接可能重开，导致闲逛的数据包当作新打开连接的数据包。在整个TCP/IP网络上，定义了一个值叫作MSL（Maximum Segment Lifetime），任何一个IP数据包在网络上逗留的最长时间是MSL，这个默认值是120s。意味者一个数据包必须最多在MSL时间内从源点传输到目的地，如果超出这个时间，中间的路由节点就会把该数据包丢弃。有了这个限定之后，一个连接保持在TIME_WAIT状态，再等待2xMSL的时间进入CLOSE状态，就可以完全避免旧的连接上面存在闲逛的数据包串到新的连接上。</li>
<li>为什么是2倍的MSL？因为网络的两将军问题，第四次发送的数据包，服务端是否收到，客户端是不知道的。服务器采取的方法是在无法收到第四次数据包的情况下重发第三次的数据包，客户端重新收到第三次数据包，再次发送第四次数据包。第四次数据包的传输时间+服务器重新发送第三次数据包的时间，最长是两倍的MSL，所以要让客户端在TIME_WAIT状态等待2倍的MSL</li>
<li>为什么服务端收到第四次数据包后，马上就进入CLOSE状态，而不用等待两倍的MSL？因为任何一个连接都是4元组，由（客户端IP、客户端Port、服务端IP、服务队Port）组成，在客户端处于TIME_WAIT状态后，意味者这个连接需要到两倍的MSL时间之后才能重新启用，服务端即使想立马使用也无法实现。</li>
</ul>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">                             +---------+ ---------\      active OPEN</span><br><span class="line">                             |  CLOSED |            \    -----------</span><br><span class="line">                             +---------+&lt;---------\   \   create TCB</span><br><span class="line">                               |     ^              \   \  snd SYN</span><br><span class="line">                  passive OPEN |     |   CLOSE        \   \</span><br><span class="line">                  ------------ |     | ----------       \   \</span><br><span class="line">                   create TCB  |     | delete TCB         \   \</span><br><span class="line">                               V     |                      \   \</span><br><span class="line">                             +---------+            CLOSE    |    \</span><br><span class="line">                             |  LISTEN |          ---------- |     |</span><br><span class="line">                             +---------+          delete TCB |     |</span><br><span class="line">                  rcv SYN      |     |     SEND              |     |</span><br><span class="line">                 -----------   |     |    -------            |     V</span><br><span class="line">+---------+      snd SYN,ACK  /       \   snd SYN          +---------+</span><br><span class="line">|         |&lt;-----------------           ------------------&gt;|         |</span><br><span class="line">|   SYN   |                    rcv SYN                     |   SYN   |</span><br><span class="line">|   RCVD  |&lt;-----------------------------------------------|   SENT  |</span><br><span class="line">|         |                    snd ACK                     |         |</span><br><span class="line">|         |------------------           -------------------|         |</span><br><span class="line">+---------+   rcv ACK of SYN  \       /  rcv SYN,ACK       +---------+</span><br><span class="line">  |           --------------   |     |   -----------</span><br><span class="line">  |                  x         |     |     snd ACK</span><br><span class="line">  |                            V     V</span><br><span class="line">  |  CLOSE                   +---------+</span><br><span class="line">  | -------                  |  ESTAB  |</span><br><span class="line">  | snd FIN                  +---------+</span><br><span class="line">  |                   CLOSE    |     |    rcv FIN</span><br><span class="line">  V                  -------   |     |    -------</span><br><span class="line">+---------+          snd FIN  /       \   snd ACK          +---------+</span><br><span class="line">|  FIN    |&lt;-----------------           ------------------&gt;|  CLOSE  |</span><br><span class="line">| WAIT-1  |------------------                              |   WAIT  |</span><br><span class="line">+---------+          rcv FIN  \                            +---------+</span><br><span class="line">  | rcv ACK of FIN   -------   |                            CLOSE  |</span><br><span class="line">  | --------------   snd ACK   |                           ------- |</span><br><span class="line">  V        x                   V                           snd FIN V</span><br><span class="line">+---------+                  +---------+                   +---------+</span><br><span class="line">|FINWAIT-2|                  | CLOSING |                   | LAST-ACK|</span><br><span class="line">+---------+                  +---------+                   +---------+</span><br><span class="line">  |                rcv ACK of FIN |                 rcv ACK of FIN |</span><br><span class="line">  |  rcv FIN       -------------- |    Timeout=2MSL -------------- |</span><br><span class="line">  |  -------              x       V    ------------        x       V</span><br><span class="line">   \ snd ACK                 +---------+delete TCB         +---------+</span><br><span class="line">    ------------------------&gt;|TIME WAIT|------------------&gt;| CLOSED  |</span><br><span class="line">                             +---------+                   +---------+</span><br><span class="line"></span><br><span class="line">                     TCP Connection State Diagram</span><br></pre></td></tr></table></figure>
<p>摘抄至<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a>第22页的TCP连接状态图。</p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>QUIC（Quick UDP Internet Connection）是由Google公司提出的基于UDP协议的多路并发传输协议。QUIC可以解决TCP的“队头阻塞”问题。QUIC包含的特征有：</p>
<ul>
<li>不丢包（Raid5和Raid6）</li>
<li>更少的RTT</li>
<li>连接迁移</li>
</ul>
<h1 id="TCP流量控制、拥塞控制"><a href="#TCP流量控制、拥塞控制" class="headerlink" title="TCP流量控制、拥塞控制"></a>TCP流量控制、拥塞控制</h1><p>参考<a href="https://zhuanlan.zhihu.com/p/37379780" target="_blank" rel="noopener">TCP流量控制、拥塞控制</a>。</p>
<h1 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h1><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>早起服务端网络编程模型中，使用一个线程启动一个连接LISTEN，等待新的客户端连接请求，当收到请求后，创建一个新线程，该线程阻塞式的读取客户端发送来的消息和发送消息到客户端。这种方式存在严重的性能问题，由于线程数量太多时，操作系统将会花大部分时间在线程上线文切换中，系统资源很容易耗光，不能有效处理客户端请求，造成著名的<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener">C10K</a>问题。</p>
<p>为了解决上面的问题，使用IO多路复用，用一个线程监听所有的客户端连接状态，检查是否有数据请求。IO多路复用也称为事件驱动IO。</p>
<h3 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h3><p><a href="http://man7.org/linux/man-pages/man2/select.2.html" target="_blank" rel="noopener">select</a>函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为fd是一个int值，所以fd_set其实是一个bit数组，每一位表示一个fd是否有读事件或者写事件</li>
<li>第一个参数表示fd个数，是readfds或者writefds的下标的最大值+1.因为fd从0开始，+1才表示个数</li>
<li>返回结果还在readfds和writefds里面，操作系统会重置所有的bit位，告知应用程序到底哪个fd上面有事件，应用程序需要自己从0到maxfds-1遍历所有的fd，然后执行响应的read/write操作</li>
<li>每次当select调用返回后，在下一次调用之前，要重新维护readfds和writefds</li>
</ul>
<p><strong>select受FD_SETSIZE的限制</strong>。</p>
<p><a href="http://man7.org/linux/man-pages/man2/poll.2.html" target="_blank" rel="noopener">poll</a>函数声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上面的函数会发现，select、poll每次调用都需要应用程序把fd的数组传进去，这个fd的数组每次都要在用户态和内核态之间传递，影响效率。为此，epoll设计了“逻辑上的epfd”，epfd是一个数字，把fd数组关联到上面，然后每次向内核传递的是epfd这个数字。</p>
<p>select/poll的使用举例见<a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/" target="_blank" rel="noopener">LINUX – IO MULTIPLEXING – SELECT VS POLL VS EPOLL</a>。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p><a href="http://man7.org/linux/man-pages/man7/epoll.7.html" target="_blank" rel="noopener">epoll</a>相关函数的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll句柄，size用来告诉内核监听的数目一共有多少。</span></span><br><span class="line"><span class="comment">// 其中的size并不要求是准确的数字，只是告诉内核，计划监听多少个fd。</span></span><br><span class="line"><span class="comment">// 实际通过epoll_ctl添加的fd数目可能大于这个值。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个fd增/删/改到epfd里，对应的事件也即读/写</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中的maxevents也是可以自定义的。假如有100个fd，而maxevents只设置为64，</span></span><br><span class="line"><span class="comment">// 则其他fd，上面的事件会在下次调用epoll_wait时返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>整个epoll过程分成三个步骤：</p>
<ul>
<li>事件注册：通过函数epoll_ctl实现。对于服务器而言，是accept、read、write三种事件；对于客户端而言，是connect、read、write三种事件。</li>
<li>轮询这三个事件是否就绪：通过函数epoll_wait实现。有事件发生，该函数返回。</li>
<li>事件就绪，执行实际的IO操作：通过函数accept、read、write实现。</li>
</ul>
<p>事件就绪的说明：</p>
<ul>
<li>read事件就绪：指远程有新数据来了，socket读取缓冲区里有数据，需要调用read函数处理</li>
<li>write事件就绪：指本地的socket写缓冲区是否可写。如果写缓冲区没有满，则一直都是可写的，write事件一直是就绪的，可以调用write函数。只有当遇到发送大文件的场景时，socket写缓冲区被占满时，write事件才不是就绪状态</li>
<li>accept事件就绪：有新的连接你如，需要调用accept函数处理</li>
</ul>
<p>epoll里面有两种模式：LT（水平触发）和ET（边缘触发）。水平触发又称条件触发，边缘触发又称状态触发。</p>
<ul>
<li>水平触发：读缓冲区只要不为空，就会一直触发读事件；写缓冲区只要不满，就会一直触发写事件</li>
<li>边缘触发：读缓冲区的状态，从空转为非空的时候触发一次；写缓冲区的状态从满转为非满时触发一次。</li>
</ul>
<p>关于LT和ET，有两点需要注意的问题：</p>
<ul>
<li>对于LT模式，要避免“写的死循环”问题：写缓冲区为满的概率很小，即“写的条件”会一直满足，所以当用户注册了写事件却没有数据要写时，它会一直触发，因此在LT模式下写完数据一定要取消写事件</li>
<li>对于ET模式，要避免“short read”问题：例如用户收到100个字节，它触发1次，用户只读到了50个字节，剩下的50字节不读，它也不会再次触发。因此在ET模式下，一定要把“读缓冲区”的数据一次性全部读完</li>
</ul>
<p>在事件开发中，一般倾向于用LT，这也是默认的模式，Java NIO用的也是epoll的LT模式。因为ET容易漏事件，一次触发如果没有处理好，就没有第二次机会了。虽然LT重复触发可能有少许性能损耗，但更安全。</p>
<p>基于IO多路复用的高并发学习框架<a href="https://github.com/yedf/handy" target="_blank" rel="noopener">handy</a>。</p>
<h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>Java NIO的4个重要抽象API是</p>
<ul>
<li>Buffers，数据缓冲区</li>
<li>Charsets，表示字符到字节的编码和解码</li>
<li>Channels，表示可执行IO操作的网络连接，或者称其为数据流，可执行读写操作</li>
<li>Selectors，表示epoll的IO多路复用</li>
</ul>
<p>Java NIO可以使用一个Selector线程处理所有的Channel连接。Channel和Buffer使用直接缓冲区实现“零拷贝”<a href="https://en.wikipedia.org/wiki/Zero-copy" target="_blank" rel="noopener"> [2] </a>。</p>
<p><img src="/images/java_nio_abstract.jpg" alt="Java NIO模型" title="Java NIO模型"></p>
<p>Selector举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.selectNow();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>Reactor模式称为主动模式。所谓主动，是指应用程序不断地轮询，访问操作系统或网络框架、IO是否就绪。Linux系统下的select、poll、epoll就属于主动模式，需要应用程序中有一个循环一直轮询；Java中的NIO也属于这种模式。在这种模式下，实际的IO操作还是应用程序执行的。</p>
<p>Reactor的组件：</p>
<ul>
<li>Reactor：Reactor是IO事件的派发者</li>
<li>Acceptor：Acceptor接受client连接，建立对应client的Handler，并向Reactor注册此Handler</li>
<li>Handler：和一个client通讯的实体，相当于Java NIO中的Channel。</li>
</ul>
<p>单线程的Reactor模型：</p>
<p><img src="/images/reactor_single_thread.webp" alt="单线程的Reactor模型" title="单线程的Reactor模型"></p>
<p>多线程的Reactor模型：</p>
<p><img src="/images/reactor_multiple_thread.webp" alt="多线程的Reactor模型" title="多线程的Reactor模型"></p>
<p>主从Reactor模型：</p>
<p><img src="/images/reactor_master_slave.webp" alt="主从Reactor模型" title="主从Reactor模型"></p>
<p>多线程的Reactor模型将线程分为IO线程和工作线程，详细说明见<a href="https://www.jianshu.com/p/2461535c38f3" target="_blank" rel="noopener">高性能Server—Reactor模型</a>。</p>
<p>Netty是Reactor模式的开源框架。</p>
<h2 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h2><p>Proactor称为被动模式，应用程序把read和write函数操作全部交给操作系统或者网络框架，实际的IO操作由操作系统或者网络框架完成，之后再回调应用程序。<a href="https://think-async.com/Asio/" target="_blank" rel="noopener">asio</a>库就是典型的Proactor模式。</p>
<h2 id="服务器编程中的1-N-M模型"><a href="#服务器编程中的1-N-M模型" class="headerlink" title="服务器编程中的1+N+M模型"></a>服务器编程中的1+N+M模型</h2><p>在服务器的编程中，epoll编程的三个步骤是由不同的线程负责的，即服务器编程中的1+N+M模型。</p>
<p><img src="/images/network_io_1_n_m.jpg" alt="1+N+M模型" title="1+N+M模型"></p>
<p>N的数量通知等于CPU个数，M数量一般大于N的数量，比如上百个。</p>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>Tomcat的NIO线程模型分为：</p>
<ul>
<li>Acceptor线程：接收客户端连接的线程，通过<code>ServerSocket.accept()</code>获得<code>SocketChannel</code>对象，将该对象封装在<code>org.apache.tomcat.util.net.NioChannel</code>对象中，继续将<code>NioChannel</code>对象封装在<code>PollerEvent</code>对象中，并将<code>PollerEvent</code>对象压入events queue里。Acceptor与Poller线程之间通过events queue通信，Acceptor是events queue的生产者，Poller是events queue的消费者。</li>
<li>Poller线程：Poller线程中维护了一个<code>Selector</code>对象，是NIO实现的主要线程。首先作为events queue的消费者，从queue中取出<code>PollerEvent</code>对象，然后将此对象中的channel以<code>OP_READ</code>事件注册到<code>Selector</code>中，然后<code>Selector</code>执行<code>select</code>操作，遍历出可以读数据的socket，并从Worker线程池中拿到可用的Worker线程，将socket传递给Worker。</li>
<li>Worker线程：Worker线程拿到Poller传过来的socket后，将socket封装在<code>SocketProcessor</code>对象中。然后从<code>Http11ConnectionHandler</code>中取出<code>Http11NioProcessor</code>对象，从<code>Http11NioProcessor</code>中调用<code>CoyoteAdapter</code>的逻辑。在Worker线程中，会完成从socket中读取http request，解析成<code>HttpServletRequest</code>对象，分派到相应的servlet并完成逻辑，然后将response通过socket发回client。在从socket中读数据和往socket中写数据的过程，并没有像典型的非阻塞的NIO的那样，注册<code>OP_READ</code>或<code>OP_WRITE</code>事件到<code>Selector</code>，而是直接通过socket完成读写，这时是阻塞完成的。</li>
</ul>
<p><img src="/images/tomcat_thread_model.jpg" alt="Tomcat NIO线程模型" title="Tomcat NIO线程模型"></p>
<p>Tomcat的线程模型详细见<a href="https://blog.csdn.net/qq_16681169/article/details/75003640" target="_blank" rel="noopener">tomcat 线程模型</a>。</p>
<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>Nginx的多进程模型可分为：</p>
<ul>
<li>Master进程：Master进程启动时调用listen创建监听端口，然后使用fork创建Worker进程，通过信号控制Worker进程。</li>
<li>Worker进程：Worker进程由于是Master进程fork而来，继承了Master进程监听端口的fd，使用<code>accept_mutex</code>控制“惊群效应”，接收客户端请求。每个Worker进程都使用epoll实现IO多路复用。</li>
</ul>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://stltqhs.github.io/2018/10/13/java-programmer-knowledge-network/" title="Java后端开发 - 网络" target="_blank" rel="external">https://stltqhs.github.io/2018/10/13/java-programmer-knowledge-network/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/stltqhs" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/stltqhs" target="_blank"><span class="text-dark">海东青</span><small class="ml-1x">Java 技术专家</small></a></h3>
        <div>熟练 JVM、多线程、MySQL、容器化及云原生虚拟技术。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2018/10/13/java-programmer-knowledge-algorithm/" title="Java后端开发 - 算法和数据结构"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2018/10/13/java-programmer-knowledge-design-pattern/" title="Java后端开发 - 设计模式"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   




   





    <script defer>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?be79fae6ef126e586106ff806c368fc7";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>



</body>
</html>