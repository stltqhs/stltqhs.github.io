<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>计算机体系结构——为什么需要内存屏障 | 海东青</title>
  <meta name="description" content="本文是作者阅读了《Is Parallel Programming Hard, And, If So, What Can You Do About It?Second Edition》 一书的附录C “Why Memory Barriers” 整理出来。篇幅较长，请耐心阅读。 为什么 CPU 设计者要设计内存屏障呢，简单回答就是指令重排序的内存引用具有更高的性能，需要引入内存屏障来解决类似同步原语（">
<meta name="keywords" content="计算机体系结构">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机体系结构——为什么需要内存屏障">
<meta property="og:url" content="https://stltqhs.github.io/2020/12/18/arch-why-mem-barrier/index.html">
<meta property="og:site_name" content="海东青">
<meta property="og:description" content="本文是作者阅读了《Is Parallel Programming Hard, And, If So, What Can You Do About It?Second Edition》 一书的附录C “Why Memory Barriers” 整理出来。篇幅较长，请耐心阅读。 为什么 CPU 设计者要设计内存屏障呢，简单回答就是指令重排序的内存引用具有更高的性能，需要引入内存屏障来解决类似同步原语（">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f1_cache_structure.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f2_cache_structure.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f3_cache_state_diagram.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f4_mesi_example.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f5_writes_see_unnecessary_stalls.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f6_caches_with_store_buffers.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f7_caches_win_store_forwarding.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f8_caches_with_invalidate_queues.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_f9_example_ordering_hostile_architecture.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_list_c_1.jpg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_list_c_2.jpeg">
<meta property="og:image" content="https://stltqhs.github.io/images/memory_barrier_list_c_3.jpg">
<meta property="og:updated_time" content="2023-09-04T00:20:24.355Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="计算机体系结构——为什么需要内存屏障">
<meta name="twitter:description" content="本文是作者阅读了《Is Parallel Programming Hard, And, If So, What Can You Do About It?Second Edition》 一书的附录C “Why Memory Barriers” 整理出来。篇幅较长，请耐心阅读。 为什么 CPU 设计者要设计内存屏障呢，简单回答就是指令重排序的内存引用具有更高的性能，需要引入内存屏障来解决类似同步原语（">
<meta name="twitter:image" content="https://stltqhs.github.io/images/memory_barrier_f1_cache_structure.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://stltqhs.github.io/2020/12/18/arch-why-mem-barrier/index.html">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/stltqhs" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">海东青</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java 技术专家</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Guangzhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSQL/">NoSQL</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/">mq</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/云原生/">云原生</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/人工智能/">人工智能</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机体系结构/">计算机体系结构</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/NoSQL/" style="font-size: 13.33px;">NoSQL</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/mq/" style="font-size: 13px;">mq</a> <a href="/tags/云原生/" style="font-size: 13.33px;">云原生</a> <a href="/tags/人工智能/" style="font-size: 13px;">人工智能</a> <a href="/tags/大数据/" style="font-size: 13.67px;">大数据</a> <a href="/tags/算法/" style="font-size: 13px;">算法</a> <a href="/tags/网络/" style="font-size: 13.33px;">网络</a> <a href="/tags/计算机体系结构/" style="font-size: 13.33px;">计算机体系结构</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/09/Linux-kernel-about-network-second/" class="title">Linux 网络简说（下）</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-09T14:31:05.000Z" itemprop="datePublished">2023-09-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/09/Linux-kernel-about-network/" class="title">Linux 网络简说（上）</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-09T08:20:24.000Z" itemprop="datePublished">2023-09-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/08/Borg-Omega-and-Kubernates/" class="title">Borg, Omega, and Kubernates</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-08T06:40:38.000Z" itemprop="datePublished">2023-09-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/07/Borg/" class="title">Borg</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-07T05:13:17.000Z" itemprop="datePublished">2023-09-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2023/09/03/Milvus/" class="title">Milvus</a>
              </p>
              <p class="item-date">
                <time datetime="2023-09-03T09:18:33.000Z" itemprop="datePublished">2023-09-03</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Cache-结构"><span class="toc-number">1.</span> <span class="toc-text">Cache 结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存一致性"><span class="toc-number">2.</span> <span class="toc-text">缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MESI-状态"><span class="toc-number">2.1.</span> <span class="toc-text">MESI 状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MESI-协议消息"><span class="toc-number">2.2.</span> <span class="toc-text">MESI 协议消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MESI-状态图"><span class="toc-number">2.3.</span> <span class="toc-text">MESI 状态图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MESI-协议举例"><span class="toc-number">2.4.</span> <span class="toc-text">MESI 协议举例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Store-Result-in-Unnecessary-Stalls"><span class="toc-number">3.</span> <span class="toc-text">Store Result in Unnecessary Stalls</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Store-Buffers"><span class="toc-number">3.1.</span> <span class="toc-text">Store Buffers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Store-Forwarding"><span class="toc-number">3.2.</span> <span class="toc-text">Store Forwarding</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#store-buffers-和内存屏障"><span class="toc-number">3.3.</span> <span class="toc-text">store buffers 和内存屏障</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Store-Sequences-Result-in-Unnecessary-Stalls"><span class="toc-number">4.</span> <span class="toc-text">Store Sequences Result in Unnecessary Stalls</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Invalidate-队列"><span class="toc-number">4.1.</span> <span class="toc-text">Invalidate 队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Invalidate-队列和-Invalidate-Acknowledge"><span class="toc-number">4.2.</span> <span class="toc-text">Invalidate 队列和 Invalidate Acknowledge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Invalidate-队列和内存屏障"><span class="toc-number">4.3.</span> <span class="toc-text">Invalidate 队列和内存屏障</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读写内存屏障"><span class="toc-number">5.</span> <span class="toc-text">读写内存屏障</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存屏障的顺序"><span class="toc-number">6.</span> <span class="toc-text">内存屏障的顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ordering-Hostile-Architecture"><span class="toc-number">6.1.</span> <span class="toc-text">Ordering-Hostile Architecture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例1"><span class="toc-number">6.2.</span> <span class="toc-text">例1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例2"><span class="toc-number">6.3.</span> <span class="toc-text">例2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#例3"><span class="toc-number">6.4.</span> <span class="toc-text">例3</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-arch-why-mem-barrier" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      计算机体系结构——为什么需要内存屏障
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/12/18/arch-why-mem-barrier/" class="article-date">
	  <time datetime="2020-12-18T08:59:05.000Z" itemprop="datePublished">2020-12-18</time>
	</a>
</span>
        
        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/计算机体系结构/">计算机体系结构</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/12/18/arch-why-mem-barrier/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <p>本文是作者阅读了<a href="https://arxiv.org/pdf/1701.00854.pdf" target="_blank" rel="noopener">《Is Parallel Programming Hard, And, If So, What Can You Do About It?Second Edition》</a> 一书的附录C “Why Memory Barriers” 整理出来。篇幅较长，请耐心阅读。</p>
<p>为什么 CPU 设计者要设计内存屏障呢，简单回答就是<strong>指令重排序的内存引用具有更高的性能，需要引入内存屏障来解决类似同步原语（synchronized primitives）这类的顺序读写内存操作</strong>。要想完全搞清楚这个问题，需要理解 CPU 的缓存 cache是如何工作的，特别是要需要清楚的知道怎样操作才能让缓存利用更加高效。</p>
<p>本文包括：</p>
<ul>
<li>Cache 的结构；</li>
<li>缓存一致性协议（cache-coherency protocol）确保 CPU 能读写同一个内存数据；</li>
<li>store buffer 和 invalidate queue 帮助缓存和缓存一致性协议达到更高的性能；</li>
</ul>
<h1 id="Cache-结构"><a href="#Cache-结构" class="headerlink" title="Cache 结构"></a>Cache 结构</h1><p>现代的 CPU 处理速度远快于现代的内存系统，一个 2006 年产的 CPU 每纳秒可以执行 10 个指令，但是需要 10+ 纳秒（tens of nanoseconds）才能从内存里拿出一个数据。这种速度不相称的情况就造成了现代 CPU 会有多个 Cache，每一核关联一个 Cache。如图-1所示。</p>
<p><img src="/images/memory_barrier_f1_cache_structure.jpg" alt="memory_barrier_f1_cache_structure" width="35%"></p>
<p><em>图-1 现代计算机系统的缓存结构</em></p>
<p>数据以固定大小的块从内存流转到 cache ，这个固定大小的块就是缓存行（cache line），它是 2 的幂次，范围从 16 到 256 字节不等。当一个 CPU 第一次读取一个数据时，这个数据必定不在缓存内，称为缓存失效（cache miss，还可以细分为 startup 缓存失效和 warmup 缓存失效）。缓存失效意味着 cpu 需要等待多个时钟周期去内存中加载数据。由于数据是被加载到 cache 缓存，所以读取后续的数据能够命中缓存，能以最快的速度执行。</p>
<p>CPU 运行一段时间后，cache 会被数据填满，此时又需要将 cache 内的旧数据移除，以便腾出空间存储最新读取的数据。这被称为容量失效（capacity miss），因为这是由于 cache 容量限制导致的。事实上，很多旧数据被移除时，并不需要等到 cache 缓存被填满，当某些缓存行还有空间剩余时，旧的数据也需要被移除，腾出空间给新来的数据。这是因为 cache 被设计成一个硬件类型的 hash 表，hash 表有固定大小的 hash 桶（hash bucket，或者组 set），非链式结构，如图-2所示。</p>
<p><img src="/images/memory_barrier_f2_cache_structure.jpg" alt="memory_barrier_f2_cache_structure" width="35%"></p>
<p><em>图-2 缓存结构</em></p>
<p>图-2所示是两路组相联的  cache （a two-way set-associative cache），每一路有16组，合起来就是 32 个缓存行，每一个格子就包含了 256 字节的缓存行，按 256 字节对齐。缓存行大小按这种方式对齐，对于十六进制计算非常简单。这种硬件实现的 hash 表，我们可以把它与软件实现的 hash 表做个类比：软件 hash 表有 16 个 hash 桶，每个桶有最多两个元素的链表。由于缓存 hash 表是由硬件实现，hash 函数非常简单，就是从内存地址中取 4 位。</p>
<p>图-2所示的缓存有 32 个格子，每个格子就是一个 256 字节大小的缓存行。有些格子还是空的，有些格子已经被填满。填满的标记是一个内存地址，表示该缓存行存储的数据是这个内存地址开始到256字节结束的数据。因为缓存行必须按照 256 字节对齐，所以缓存行的的首地址的低8位都是0，硬件的缓存 hash 算法就采用下一个4位作为缓存行的索引。</p>
<p>以图-2为例举一个场景来说明缓存行的工作模式。某一个程序代码的地址是从 0x43210E00 到<br>0x43210EFF，这个程序顺序的从 0x12345000 到 0x12345EFF 的数据。假如这个程序现在要读取地址 0x12345F00 的数据，根据 hash 函数可以算出这个地址的缓存行是 0xF，而图-2所示的 0xF 缓存行的两路格子都是空的，所以这个内存地址的数据可以直接存放在缓存行内。如果这个程序要读取地址 0x1233000 ，根据 hash 函数可以算出这个地址的缓存行是 0x0，这个地址的数据支持存储在右边那个格子上，因为只有这个格子是空的。但是如果程序要读取 0x1233E00 这个地址的数据，根据 hash 函数算出缓存行是 0xE，现在这两个格子都填满了数据，需要将其中一个格子的数据清空，用来存放 0x1233E00 这个地址的数据。如果被清空的地址后面又被读取，此时又会出现缓存失效的情况。</p>
<p>到目前为止，我们讨论的都是读取缓存的问题，那么对于写缓存会发生哪些事情呢？最重要的是要让多核 CPU 都认同一个数据为同一个值，当一个 CPU 准备写入一个数据时，它需要先通知其他 CPU 将其缓存失效或者移除。如果其他 CPU 已经使数据失效或者移除，这个 CPU 就可以将数据写入到自己的 CPU 缓存中。使用读、写会造成一个数据在多个 CPU 中会有不同的值，而失效操作会使得其他 CPU 的数据丢失。要解决这些问题就需要缓存一致性协议。</p>
<h1 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h1><p><strong>缓存一致性协议管理缓存行的状态，以便防止数据丢失和不一致问题</strong>。缓存一致性协议非常复杂，有几十种状态，但在本节只会讲常用的4种，即 MESI 。</p>
<h2 id="MESI-状态"><a href="#MESI-状态" class="headerlink" title="MESI 状态"></a>MESI 状态</h2><p>MESI 代表 “modified”（修改），“exclusive”（独占），“shared”（共享） 和“invalid”（失效），他们表示缓存行的状态。这4种状态可以用2位来表示，每一个缓存行就是物理内存地址+数据+2位状态标签。</p>
<p>“modified”状态的缓存行表示它的数据已经被修改，准备写回到内存，其他的 CPU 没有这份内存数据，也就是说 CPU 拥有这块内存的数据独占资源，因此它有最新数据的一份拷贝。<strong>这种状态的CPU职责有两个，一个是准备写回到内存，另一个就是写回前被其他CPU读走，其他CPU拥有独占资源</strong>。</p>
<p>“exclusive”与“modified”非常相似，唯一的不同是 CPU 还未修改缓存行，它表示 “exclusive”状态的缓存行拥有最新数据的一份拷贝。“exclusive”状态的缓存行也意味着 CPU 独享，它可以在任意时刻对这个缓存行再次修改，其他 CPU 缓存没有这份数据的拷贝。由于“exclusive”状态的缓存行是未被修改的数据，所以它无需写回到内存。</p>
<p>“shared”状态的缓存行表示缓存行至少有2个CPU都共享了这些数据。所以当一个 CPU 想要修改缓存行数据时，必须要提前向其他 CPU 查询一下，不允许直接修改。“shared”缓存行对应的内存数据是最新的，也不需要写回到内存。</p>
<p>“invalid”状态的缓存行表示数据是空的，也就是这个缓存行没有数据。如果数据要想放到缓存行，缓存行的状态最好是“invalid”状态。如果是其他状态，会出现昂贵的缓存失效操作，因为这部分数据后面大概率会被访问。</p>
<p>因为说有的 CPU 都需要保持数据一致性，缓存一致性协议提供了协调缓存行状态移动的消息。</p>
<h2 id="MESI-协议消息"><a href="#MESI-协议消息" class="headerlink" title="MESI 协议消息"></a>MESI 协议消息</h2><p>MESI 的状态转移需要多个 CPU 之间进行通信，对于一个共享总线的计算机系统，需要用到这些消息：</p>
<ul>
<li><strong>Read</strong>：向缓存行发起读取一个物理地址数据的操作；</li>
<li><strong>Read Response</strong>：响应 <strong>Read</strong> 消息的结果，<strong>Read Response</strong> 可能是内存响应，也可能是其他CPU的缓存行响应。如果一个缓存行的状态是“modified”并且包含 <strong>Read</strong> 请求的数据，该缓存行必须响应这个 <strong>Read</strong> 请求；</li>
<li><strong>Invalidate</strong>：发起让一个包含指定物理地址的缓存行失效的请求，所有的CPU缓存都必须清除这个物理地址的数据；</li>
<li><strong>Invalidate Acknowledge</strong>：一个CPU收到 <strong>Invalidate</strong> 后清除了数据就必须回复 <strong>Invalidate Acknowledge</strong> 消息；</li>
<li><strong>Read Invalidate</strong>：是 <strong>Read</strong> 和 <strong>Invalidate</strong> 两个操作的合并，发起一个 <strong>Read</strong> 请求后还需要向其他CPU发起 <strong>Invalidate</strong> 请求，它需要搜到两种类型的消息回复，一个是 <strong>Read Response</strong> ，另一个是 <strong>Invalidate Acknowledge</strong>；</li>
<li><strong>Writeback</strong>：写回的消息包含了写到内存的物理地址和数据，这个消息可以将“modified”状态的缓存行失效，释放空间用来存储其他数据；</li>
</ul>
<h2 id="MESI-状态图"><a href="#MESI-状态图" class="headerlink" title="MESI 状态图"></a>MESI 状态图</h2><p>当一个缓存行发起和接收MESI消息时，它的状态变化如图-3所示。</p>
<p><img src="/images/memory_barrier_f3_cache_state_diagram.jpg" alt="memory_barrier_f3_cache_state_diagram" width="35%"></p>
<p><em>图-3 MESI 缓存一致性状态图</em></p>
<p>每条线的状态转移过程如下：</p>
<ul>
<li>a ：缓存行写回到内存但是还要继续保留缓存行的修改权限，这个状态转移需要 <strong>Writeback</strong> 消息；</li>
<li>b ：CPU 向独占（exclusive）的缓存行发起写操作，这个状态转移不需要任何消息；</li>
<li>c ：发生在当一个“modified”状态缓存行的CPU收到 <strong>Read Invalidate</strong> 的请求时。CPU必须清空这个缓存行的数据，并且回复 <strong>Read Response</strong> 和 <strong>Invalidate acknowledge</strong> 消息，这两个消息都需要发送到请求的CPU，表示这个CPU不再拥有这份数据；</li>
<li>d ：一个CPU对一个数据项执行了“read-modify-write”原子操作，而这份数据又不在缓存行中。CPU发起一个 <strong>Read Invalidate</strong> 消息，然后需要收到内存或者其他CPU的 <strong>read response</strong> 消息，如果这个CPU还收到了 <strong>Invalidate Acknowledge</strong> 消息后，它就可以完成这个原子操作的状态转移。</li>
<li>e ：一个CPU对一个已存在缓存行中的只读数据项发起了“read-modify-write”原子操作。必须先发起一个 <strong>Invalidate</strong> 消息，然后等所有的CPU都回复了 <strong>Invalidate Acknowledge</strong> 消息才能完成这个状态转移。</li>
<li>f ：一个CPU读另一个CPU的缓存行，这个缓存行已完成写回内存且保持只读。要完成这个状态转移首先这个CPU需要接收到一个 <strong>Read</strong> 消息，然后此CPU回复 <strong>Read Response</strong> 消息。</li>
<li>g ：一个CPU读另一个CPU的缓存行，响应这个读操作可能是来自内存或者是另一个CPU的缓存行，不管哪种方式，另一个CPU的缓存行依然保留这份只读数据的。这个转换首先是缓存行接收到了 <strong>Read</strong> 消息，然后响应 <strong>Read Response</strong> 消息。</li>
<li>h ：CPU意识到它将要立马写一些数据到一个缓存行，因此发起一个 <strong>Invalidate</strong> 消息，直到它所有了其他所有CPU的 <strong>Invalidate Acknowledge</strong> 消息才能完成这个状态转移。相应地，其他CPU收到这个 <strong>Invalidate</strong> 消息后需要将数据写回到内存（如果有脏数据），然后从缓存行删除这些数据，可以腾出空间给其他数据。最后就只有发起 <strong>Invalidate</strong> 消息的这个CPU缓存了这份数据。</li>
<li>i ：其他CPU对当前缓存行持有的数据项执行了“read-modify-write”操作，当前缓存行需要从这个CPU上失效。这个状态转移首先是这个CPU收到了 <strong>Read Invalidate</strong> 消息后，然后回复 <strong>Read Response</strong> 和 <strong>Invalidate Acknowledge</strong> 消息。 </li>
<li>j ：CPU要写一份数据到缓存行，由于要独占，因此需要发起 <strong>Read Invalidate</strong> 消息，直到收到 <strong>Read Response</strong> 且所有其他的CPU都回复了 <strong>Invalidate Acknowledge</strong> 才能完成状态转移。可以通过 b 完成 exclusive 到 modified 的状态转移。</li>
<li>k ：CPU发起 <strong>Read</strong> 消息读取一项数据到缓存行，收到 <strong>Read Response</strong> 即可完成状态转移。</li>
<li>l ：其他CPU将一项数据存储到缓存行，这项数据目前正存储在当前CPU的缓存行。状态转移发生在CPU收到 <strong>Invalidate</strong> 消息后，该CPU回复 <strong>Invalidate Acknowledge</strong> 消息。</li>
</ul>
<h2 id="MESI-协议举例"><a href="#MESI-协议举例" class="headerlink" title="MESI 协议举例"></a>MESI 协议举例</h2><p>为了简单起见，我们使用一个4核CPU，每个CPU只有一个缓存行来举例。首先，缓存行的数据一开始是放在内存0地址上。如图-4所示，表格显示了缓存行和内存之间的数据流，第1栏是每个操作的序号，第2栏是CPU执行这个操作的CPU编号，第3栏是操作的名称，第4栏是CPU缓存行的状态，最后两栏表示的是内存数据是否是最新的，V 表示最新，I 表示不是最新。注意表-4中的 Load 和 Store 针对的都是缓存行，<strong>Load 表示加载数据到缓存行，Store 表示修改缓存行或者写数据到缓存行</strong>。</p>
<p><img src="/images/memory_barrier_f4_mesi_example.jpg" alt="memory_barrier_f4_mesi_example" width="60%"></p>
<p><em>图-4 MESI 缓存一致性举例</em></p>
<p>首先，CPU缓存行都是空的，状态是“invalid”，数据在内存中的状态是“valid”，表示内存中的数据是最新的。当0号CPU从地址0加载数据，它进入到0号CPU缓存行，状态为“shared”，此时内存中的数据依然是最新的。第3号CPU也从地址0加载这项数据，所以这两个CPU都有一份共享的数据，状态都是“shared”，内存中的数据还是最新的。</p>
<p>接着，0号CPU读取地址8的数据到缓存行，由于缓存行空间不够，本操作强制将缓存行中的数据清空，填充地址8的数据。2号CPU也从0地址加载数据，它意识到自己将要立马修改这个缓存行，所以它使用 <strong>Read Invalidate</strong> 消息以便自己能获得数据独占的要求，因此将3号CPU包含0地址的缓存行数据清空。然后2号CPU执行下一个 Store 指令，将它的修改对应的缓存行数据，此时缓存行的状态是“modified”状态。此时内存中的数据已经不是最新的数据，缓存行的数据才是最新的。</p>
<p>1号CPU执行一个原子自增操作，需要使用 <strong>Read Invalidate</strong> 消息探测一下其他CPU是否有地址0的数据，此时2号CPU它正好有1号CPU需要的数据，因此2号CPU需要回复 <strong>Read Response</strong> 消息，与此同时，还要将自己的数据清空，回复 <strong>Invalidate Acknowledge</strong> 消息。现在1号CPU的状态是“modified”状态，对应内存的数据也不是最新的。</p>
<p>最后，1号CPU通过 <strong>Writeback</strong> 消息将数据写入到地址0，然后读取地址8的数据到缓存行。</p>
<h1 id="Store-Result-in-Unnecessary-Stalls"><a href="#Store-Result-in-Unnecessary-Stalls" class="headerlink" title="Store Result in Unnecessary Stalls"></a>Store Result in Unnecessary Stalls</h1><p><em>标题可能翻译不准，保留英文原文，含义是“不停顿地保存结果”。</em></p>
<p>尽管图4中的CPU结构对于一个CPU重复读写给定数据有很好的性能，但是对于第一次写数据时，性能会比较糟糕。图-5所示是 CPU 0 写操作的一个时间线，当CPU 0要写的缓存行数据存在 CPU 1 时，需要先获得缓存行的独占资源，因此需要向 CPU 1 发起 <strong>Read Invalidate</strong> 消息，CPU 1 回复 <strong>Read Response</strong> 消息和 <strong>Invalidate Acknowledge</strong> 消息时，CPU 0才能完成“exclusive”状态，这样才能写数据。而等待 <strong>Read Response</strong> 和 <strong>Invalidate Acknowledge</strong> 需要花一定的时间。</p>
<p><img src="/images/memory_barrier_f5_writes_see_unnecessary_stalls.jpg" alt="memory_barrier_f5_writes_see_unnecessary_stalls" width="35%"></p>
<p><em>图-5 非必要的写停顿</em></p>
<p>然而我们也没有必要真的让CPU 0等待那么长时间，毕竟，不管CPU 1发送了什么数据到这个缓存行，CPU 0都会无条件的覆盖它。</p>
<h2 id="Store-Buffers"><a href="#Store-Buffers" class="headerlink" title="Store Buffers"></a>Store Buffers</h2><p><em>store buffer 可以翻译为缓存行写缓存区，不过本文依然使用英文 store buffer 来表示，不用中文表达。</em></p>
<p>有一种阻止没必要写停顿的方法是在CPU和缓存之间加一个 <strong>Store Buffers</strong>，如图-6所示。</p>
<p><img src="/images/memory_barrier_f6_caches_with_store_buffers.jpg" alt="memory_barrier_f6_caches_with_store_buffers" width="40%"></p>
<p><em>图-6 带有 store buffer 的缓存系统</em></p>
<p>加上额外的 store buffers 后，CPU 0 就可以简单的将操作记录存到 store buffers，然后继续执行后面的操作。比如 <code>i = 5</code> 这种写就可以先将其结果记录在 store bufffers，不管其他 CPU 存的 <code>i</code> 是多少，这个 CPU 都是会忽略的。当该数据项对应缓存行的独占资源从 CPU1转移到 CPU 0 时，之前记录在 store buffers 中的数据就可以移出写到这个缓存行中。</p>
<p>store buffers 是 CPU 局部独有非共享，也可以是硬件虚拟的一核多线程环境中被这一核局部独有。不管是哪种方式，CPU 只能访问它自己的 store buffers。比如图-6中的CPU 0不能访问CPU 1的 store buffer，反之亦然。这种限制通过分而治之的方式简化了硬件设计：store buffer 提高连续写的性能，CPU之间通过缓存一致性协议通信。</p>
<p>然而，尽管有这个限制，也还是有很多复杂的问题需要提出来，下面两节讨论。</p>
<h2 id="Store-Forwarding"><a href="#Store-Forwarding" class="headerlink" title="Store Forwarding"></a>Store Forwarding</h2><p>第一个复杂的问题是违反 self-consistency ，先看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = a + <span class="number">1</span>;</span><br><span class="line">assert(b == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>假设，变量 <code>a</code> 和变量 <code>b</code> 都初始化为 0，变量 <code>a</code> 首次放在 CPU 1 的缓存行，变量 <code>b</code> 首次放在 CPU 0 的缓存行。</p>
<p>代码简单，没有人认为断言会失败。然而，如果有人足够幼稚的使用图-6这种简单架构来考虑问题，惊喜来了。这个系统可能会出现下面这串事件：</p>
<ul>
<li>1 CPU 0 开始执行 <code>a = 1</code>；</li>
<li>2 CPU 0 在缓存中查找 <code>a</code> ，发现它不存在；</li>
<li>3 CPU 0 因此发送 <strong>Read Invalidate</strong> 消息一致获得变量 <code>a</code> 缓存行的独占权；</li>
<li>4 CPU 0 将 <code>a = 1</code> 结果记录到 store buffer；</li>
<li>5 CPU 1 接收到 <strong>Read Invalidate</strong> 消息，然后回复 <code>a</code> 缓存行的数据，即发生消息 <strong>Read Response</strong>，同时还会把 <code>a</code> 缓存行的数据失效，然后回复 <strong>Invalidate Acknowledge</strong> 消息；</li>
<li>6 CPU 0 开始执行 <code>b = a + 1</code>；</li>
<li>7 CPU 0 接收到 CPU 1 回复的缓存行数据，<code>a</code> 现在依然是 0；</li>
<li>8 CPU 0 将 <code>a</code> 从缓存行读取，放入到计算逻辑单元寄存器，准备做 <code>a + 1</code> 的计算 ，此时 <code>a</code> 的值是0；</li>
<li>9 CPU 0 将 store buffer 存储 <code>a</code> 的条目取出应用到新来的 <code>a</code> 缓存行，将缓存行中 <code>a</code> 的值设置为 1；</li>
<li>10 CPU 0 接着第8步，将 1 和值为 0 的 <code>a</code> 相加，然后将结果 1 存入到 <code>b</code> 的缓存行中（注意我们一开始就是假设 <code>b</code> 放在 CPU 0 的缓存行中）；</li>
<li>11 CPU 0 执行 <code>assert(b == 2)</code> 时，断言失败；</li>
</ul>
<p>造成失败的原因是 <code>a</code> 有两份拷贝，一份是缓存行，另一份是 store buffer。</p>
<p>这个例子打破了一个很重要的规则，这个规则保证每个CPU都能看到它的操作就好像是程序顺序执行的结果一样。打破这个保证对于软件类型来说是粗暴违反自觉的，以至于（so much so that）硬件设计者想出一个技巧，实现“store forwarding”，之后每个CPU加载数据到缓存行时都需要检查 store buffer 有没有数据，如图-7所示。换言之，<strong>一个给定的CPU的 store 操作是直接转到接下来的 load 操作，中间不再需要经过缓存行</strong>。</p>
<p><img src="/images/memory_barrier_f7_caches_win_store_forwarding.jpg" alt="memory_barrier_f7_caches_win_store_forwarding" width="40%"></p>
<p><em>图-7 带有 store forwarding 的缓存系统</em></p>
<p>使用 store forwarding 后，在第8步的时候就会发现 <code>a</code> 的正确值 1 存在 store buffer 中，所以 <code>b</code> 的最终结果将会是 2 ，这也是期望的值。</p>
<h2 id="store-buffers-和内存屏障"><a href="#store-buffers-和内存屏障" class="headerlink" title="store buffers 和内存屏障"></a>store buffers 和内存屏障</h2><p>再来看看第二个复杂的问题，一个违反全局内存顺序的问题，看看下面代码，一开始  <code>a</code>  和 <code>b</code> 都初始化为0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设 CPU 0 执行了 <code>foo()</code> 方法，CPU 1 执行了 <code>bar()</code> 方法，又假设 <code>a</code> 的缓存行存在 CPU 1 中，<code>b</code> 的缓存行存在 CPU 0 中。然后接下来的一串操作可能如下：</p>
<ul>
<li>1 CPU 0 执行 <code>a = 1</code>。由于CPU 0没有 <code>a</code> 的缓存行，所以 CPU 0 将 <code>a = 1</code> 的结果放在 store buffer 中，然后发起 <strong>Read Invalidate</strong> 消息。</li>
<li>2 CPU 1 执行 <code>while(b == 0) continue</code>，但是保存 <code>b</code> 的缓存行不在 CPU 1中，所以CPU 1发起 <strong>Read</strong> 消息。</li>
<li>3 CPU 0 执行 <code>b = 1</code>，它已经拥有 <code>b</code> 的缓存行（换言之，这个缓存行可能处于 “modified” 或者 “exclusive” 状态）。</li>
<li>4 CPU 0 收到 <strong>Read</strong> 消息，CPU 0 将 <code>b</code> 缓存行最新修改的数据发送给 CPU 1，同时将 <code>b</code> 缓存行的状态更改为 “shared”。</li>
<li>5 CPU 1 收到 <code>b</code> 缓存行的数据并将 <code>b</code> 缓存行的数据放在自己的缓存中，此时 <code>b</code> 的值是 1。</li>
<li>6 CPU 1 可能线程完成了 <code>while(b == 0) continue</code> 操作，结束了 <code>while</code> 循环，因为它发现 <code>b</code> 的值是 1，所以接着持续下面的操作。</li>
<li>7 CPU 1 执行 <code>assert(a == 1)</code>，因为 CPU 1 拿到的 <code>a</code> 还是旧值，所以断言失败。</li>
<li>8 CPU 1 收到 <strong>Read Invalidate</strong> 消息，然后将 <code>a</code> 的缓存行数据回复给 CPU 0，然后将 <code>a</code> 的缓存行从 CPU 1中移除，但是它太晚了。</li>
<li>9 CPU 0 收到 <code>a</code> 的缓存行，然后将 store buffer 中暂存的 <code>a</code> 值覆盖掉缓存行。它是 CPU 1 断言失败的罪魁祸首。</li>
</ul>
<p>硬件设计者不能直接解决这个问题，因为 CPU 无法理解变量之间的联系。因此硬件设计者提供了内存屏障的指令，允许软件开发者告诉 CPU 这种关联关系。上面的程序代码需要更新为包含内存屏障的代码，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存屏障函数 <code>smp_mb()</code> 将会让 CPU 在执行接下来的指令前刷新 store buffer 的数据到变量的缓存行。CPU 要么就暂停直到 store buffer 清空然后再执行，要么它利用 store buffer 保存接下来的 store 直到所有之前的条目都已经刷到缓存行。</p>
<p>使用内存屏障后，这串代码的一系列操作可能是：</p>
<ul>
<li>1 CPU 0 执行 <code>a = 1</code>。由于CPU 0没有 <code>a</code> 的缓存行，所以 CPU 0 将 <code>a = 1</code> 放在它的 store buffer 中，然后发起 <strong>Read Invalidate</strong> 消息。</li>
<li>2 CPU 1 执行 <code>while(b == 0) continue</code>，但是保存 <code>b</code> 的缓存行不在 CPU 1中，所以CPU 1发起 <strong>Read</strong> 消息。</li>
<li>3 CPU 0 执行 <code>smp_mb()</code>，标记当前所有的 store buffer 条目，也包括 <code>a</code> 的值 1。</li>
<li>4 CPU 0 执行 <code>b = 1</code>，它已经拥有 <code>b</code> 的缓存行（换言之，这个缓存行可能处于 “modified” 或者 “exclusive” 状态），但是发现 store buffer 已经有标记的条目。因此并不是将 <code>b</code> 的新值 1 存储到缓存行，它也将 <code>b</code> 的值放在 store buffer 中，<code>b</code> 的条目不需要标记。</li>
<li>5 CPU 0 接收到 <strong>Read</strong> 消息，它将包含 <code>b</code> 缓存行的数据发送给 CPU 1，并将自己的缓存行副本状态标记为 “shared”。</li>
<li>6 CPU 1 收到 <code>b</code> 缓存行的数据并将它放在自己的缓存行。</li>
<li>7 CPU 1 现在可以拿出 <code>b</code> 的值，但是发现 <code>b</code> 的值依然是 0，继续重复 <code>while</code> 循环。<code>b</code> 的新值现在正安全的保存在 CPU 0 的 store buffer 中。</li>
<li>8 CPU 1 收到 <strong>Read Invalidate</strong> 消息，它将 <code>a</code> 缓存行的数据发送给 CPU 0，然后清除 <code>a</code> 缓存行。</li>
<li>9 CPU 0 收到 <code>a</code> 缓存行的数据，然后应用 <code>a</code> 的 store buffer 到缓存行，更新缓存行的状态是 ”modified“ 状态。</li>
<li>10 因为 <code>a</code> 是唯一一个被 <code>smp_mb()</code> 标记的条目，所以 CPU 0 也可以存储 <code>b</code> 的新值，但是包含 <code>b</code> 缓存行的状态是 “shared”。</li>
<li>11 CPU 0 因此需要发送 <strong>Invalidate</strong> 消息给 CPU 1。</li>
<li>12 CPU 1 收到 <strong>Invalidate</strong> 消息，将包含 <code>b</code> 缓存行的清除，然后回复 CPU 0 一个 <strong>Invalidate Acknowledge</strong> 消息。</li>
<li>13 CPU 1 执行 <code>while (b == 0) continue</code> ，但是 <code>b</code> 不在缓存行中，因此向 CPU 0 发起 <strong>Read</strong> 消息。</li>
<li>14 CPU 0 收到 <strong>Invalidate Acknowledge</strong> 消息，将 <code>b</code> 缓存行的状态更改为 “exclusive” 状态，CPU 0 现在可以更新 <code>b</code> 的值到缓存行中。</li>
<li>15 CPU 0 收到 <strong>Read</strong> 消息，它将包含 <code>b</code> 最新值的缓存行发送给 CPU 1，然后将其标记为 “shared” 状态。</li>
<li>16 CPU 1 收到 <code>b</code> 缓存行的数据，然后将它更新到缓存行。</li>
<li>17 CPU 1 现在可以拿到 <code>b</code> 的新值 1，所以它退出 <code>while</code> 循环，继续往下执行。</li>
<li>18 CPU 1 执行 <code>assert(a == 1)</code> ，但是发现 <code>a</code> 不在缓存行中（第8步已经移除）。一旦它从 CPU 0 读到 <code>a</code> 缓存行的值，它可以拿到 <code>a</code> 的最新值，然后断言就成功了。</li>
</ul>
<p>正如你所看到的，流程很简单，只是 “加载 <code>a</code> 值“变得复杂了一些。</p>
<h1 id="Store-Sequences-Result-in-Unnecessary-Stalls"><a href="#Store-Sequences-Result-in-Unnecessary-Stalls" class="headerlink" title="Store Sequences Result in Unnecessary Stalls"></a>Store Sequences Result in Unnecessary Stalls</h1><p><em>标题可能翻译不准，保留英文原文，含义是“不停顿地保存一些列结果”。</em></p>
<p>不幸的是，每个 store buffer 都相当的小，意味着一个CPU一定数量的存 store buffer 的操作后，store buffer 很快会被填满（比如，一直发生 cache miss）。每当 store buffer 耗尽，CPU 就再一次等待 <strong>invalidation</strong> 完成才能执行后续的操作。相同的情形可能出现在内存屏障，当所有后续 store 指令必须等待 <strong>invalidation</strong> 完成，不管是否 store 结果是缓存失效。</p>
<p>这种情况可以通过提高 <strong>Invalidate Acknowledge</strong> 消息达到速度来解决。方法是每个CPU使用 invalidate 消息队列。</p>
<h2 id="Invalidate-队列"><a href="#Invalidate-队列" class="headerlink" title="Invalidate 队列"></a>Invalidate 队列</h2><p><strong>Invalidate Acknowledge</strong> 消息需要花很长时间的一个原因是相应的缓存行由于 cache 繁忙导致清除时间延迟。比如，一个 CPU 频繁的加载和存储数据，所有的数据也都在缓存行中。另外，如果有大量的 <strong>Invalidate</strong> 消息周期性的到达，CPU 会暂停指令执行，转而执行 <strong>Invalidate</strong> 操作，这会暂停其他所有的 CPU。</p>
<p>然而，CPU 在发送 Acknowledge 前并不需要真的清空缓存行，它会将 <strong>Invalidate</strong> 消息放入队列，在发送关于这个缓存行的任何消息前，CPU 会处理这个 <strong>Invalidate</strong> 消息。</p>
<h2 id="Invalidate-队列和-Invalidate-Acknowledge"><a href="#Invalidate-队列和-Invalidate-Acknowledge" class="headerlink" title="Invalidate 队列和 Invalidate Acknowledge"></a>Invalidate 队列和 Invalidate Acknowledge</h2><p>图-8显示一个带 Invalidate 消息队列的缓存系统。一个带有 Invalidate 队列的 CPU 可以在 invalidate 放入队列就立刻的回复 invalidate 的确认消息，这样就不需要等到相应的缓存行都真的执行了 invalidate 操作。当然，CPU 准备发送 <strong>Invalidate</strong> 消息时需要检查 invalidate 消息队列：如果相应缓存行的条目存在 invalidate 队列时，CPU 不能立刻发送 invalidte 消息，它必须等到这个 invalidate 队列的条目被执行。 </p>
<p><img src="/images/memory_barrier_f8_caches_with_invalidate_queues.jpg" alt="memory_barrier_f8_caches_with_invalidate_queues" width="40%"></p>
<p><em>图-8 带有 lnvalidate 消息队列缓存系统</em></p>
<p>CPU承诺在发送任何关于缓存行的MESI协议消息前，都会将这个缓存行的 invalidate 队列的消息取出并执行。只要相应的消息结果竞争不大，CPU的承诺也不费劲。</p>
<p>然而，事实上，invalidate 消息在 invalidate 消息队列时可以被缓存的，这样就会造成内存无序的情况，下文分析。</p>
<h2 id="Invalidate-队列和内存屏障"><a href="#Invalidate-队列和内存屏障" class="headerlink" title="Invalidate 队列和内存屏障"></a>Invalidate 队列和内存屏障</h2><p>我们假设 CPU 将 invalidate 请求加入队列，然后直接回复 invalidate acknowledge 消息。这种方法可以最小化缓存 invalidation （清除）的延迟，正如 CPU 的 store buffer 那样，但是欺骗了内存屏障。请看下面的例子。</p>
<p>假设 <code>a</code> 和 <code>b</code> 的值初始化为0，<code>a</code> 的缓存行有多个副本，也就是 “shared” 状态，<code>b</code> 存储在 CPU 0，状态是 “exclusive” 或者 “modified” 状态。然后 当 CPU 1 执行<code>bar()</code> 时，CPU 0 执行 <code>foo()</code> ，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作序列如下：</p>
<ul>
<li>1 CPU 0 执行 <code>a = 1</code>。相应的缓存行在 CPU 0的缓存中是只读，所以 CPU 0 将 <code>a</code> 的新值存到 store buffer，然后发起 <strong>Invalidate</strong> 消息要让 CPU 1中 <code>a</code> 缓存行的数据清除。</li>
<li>2 CPU 1 执行 <code>while(b == 0) continue;</code>，但是 <code>b</code> 不在缓存行中，因此发起一个 <strong>Read</strong> 消息。</li>
<li>3 CPU 1 收到 CPU 0 的 <strong>Invalidate</strong> 消息，直接将这个消息加入到 invalidate 队列，立刻回复 <strong>Invalidate Acknowledge</strong> 消息。</li>
<li>4 CPU 0 收到 CPU 1 的回复，因此可以自由的执行完 <code>smp_mb()</code> ，然后将 <code>a</code> 的值从 store buffer 取出应用到缓存行。</li>
<li>5 CPU 0 执行 <code>b = 1</code>，该 CPU 已经拥有它的缓存行（换言之，缓存行的状态可能是 “exclusive” 或者是 “modified” 状态），所以它将新值存储到缓存行中。</li>
<li>6 CPU 0 收到 <strong>Read</strong> 消息，将 <code>b</code> 的缓存行最新值发送给 CPU 1，并且标记 <code>b</code> 缓存行的状态是 “shared”。</li>
<li>7 CPU 1 收到 <code>b</code> 缓存行的数据，然后将它保存到缓存行。</li>
<li>8 CPU 1 现在可以完成 <code>while(b == 0) continue</code> ，因为它发现 <code>b</code> 的值是 1，继续执行下面的语句。</li>
<li>9 CPU 1 执行 <code>assert(a == 1)</code>，因为 <code>a</code> 的旧值依然存在 CPU 1 的缓存行中，断言失败。</li>
<li>10 不顾断言失败，CPU 1 执行 invalidate 队列的消息，标记 <code>a</code> 的缓存行失效。</li>
</ul>
<p>很明显加速了 invalidation 回复后造成内存屏障失效了。然后，内存屏障指令也可以使用在 invalidate 队列，所以，当一个 CPU 执行一个内存屏障后，它标记所有当前 invalidate 队列的条目，然后强制接下来的 load 操作等待，直到所有的被标记的条目都已经应用到缓存行。因此我们可以在 <code>bar()</code> 加一个内存屏障，代码如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    smp_mb();</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后，操作序列如下：</p>
<ul>
<li>1 CPU 0 执行 <code>a = 1</code>。相应的缓存行在 CPU 0的缓存中是只读，所以 CPU 0 将 <code>a</code> 的新值存到 store buffer，然后发起 <strong>Invalidate</strong> 消息要让 CPU 1中 <code>a</code> 缓存行的数据清除。</li>
<li>2 CPU 1 执行 <code>while(b == 0) continue;</code>，但是 <code>b</code> 不在缓存行中，因此发起一个 <strong>Read</strong> 消息。</li>
<li>3 CPU 1 收到 CPU 0 的 <strong>Invalidate</strong> 消息，直接将这个消息加入到 invalidate 队列，立刻回复 <strong>Invalidate Acknowledge</strong> 消息。</li>
<li>4 CPU 0 收到 CPU 1 的回复，因此可以自由的执行完 <code>smp_mb()</code> ，然后将 <code>a</code> 的值从 store buffer 取出应用到缓存行。</li>
<li>5 CPU 0 执行 <code>b = 1</code>，该 CPU 已经拥有它的缓存行（换言之，缓存行的状态可能是 “exclusive” 或者是 “modified” 状态），所以它将新值存储到缓存行中。</li>
<li>6 CPU 0 收到 <strong>Read</strong> 消息，将 <code>b</code> 的缓存行最新值发送给 CPU 1，并且标记 <code>b</code> 缓存行的状态是 “shared”。</li>
<li>7 CPU 1 收到 <code>b</code> 缓存行的数据，然后将它保存到缓存行。</li>
<li>8 CPU 1 现在可以完成 <code>while(b == 0) continue</code> ，因为它发现 <code>b</code> 的值是 1，继续执行下面的语句。</li>
<li>9 到了 <code>smp_mb()</code>，CPU 1 必须暂停直到所有之前的 invalidate 队列的消息都执行完成。</li>
<li>10 CPU 1 现在执行 invalidate 消息，将 <code>a</code> 缓存行清除。</li>
<li>11 CPU 1 执行 <code>assert(a == 1)</code> ，由于 <code>a</code> 的缓存行之前被清除，已经不在 CPU 1 的缓存中，需要发起 <strong>Read</strong> 消息。</li>
<li>12 CPU 0 回复 <strong>Read</strong> 消息，消息包含 <code>a</code> 缓存行的数据。</li>
<li>13 CPU 1 收到 <code>a</code> 缓存行的数据，值为 1，所以断言成功。</li>
</ul>
<p>通过很多 MESI 消息传输，CPU 能正确执行得到正确的结果。这一部分展示了为什么 CPU 设计者会十分关心他们的缓存一致性优化。</p>
<h1 id="读写内存屏障"><a href="#读写内存屏障" class="headerlink" title="读写内存屏障"></a>读写内存屏障</h1><p>前面的章节说到，内存屏障用来标记 store buffer 和 invalidate 队列的条目。但是在我们给的示例代码中，<code>foo()</code> 没有理由对 invalidate 队列做任何事，<code>bar()</code> 也没有理由对 store buffer 做任何事。</p>
<p>很多的 CPU 架构因此提供较弱的内存屏障指令，这些指令处理 invalidate 或者 store buffer 其中的一个，又或者两个多处理。粗略的说，“读内存屏障”仅标记 invalidate 队列，“写内存屏障”仅标记 store buffer，完整功能内存屏障指令两个都标记。</p>
<p>读内存屏障的效果是仅对 CPU 的 load 操作（或者读操作）排序，如此一来，所有在读内存屏障前的 load 操作都必须先完成才能执行读内存屏障之后的 load 操作。同样的，写内存屏障的效果是仅对 CPU 的 store 操作（或者写操作）排序，如此一来，所有在写内存屏障之前的 store 操作比先完成才能执行写内存屏障之后的 store 操作。完整功能内存屏障指令对 load 和 store 都排序。</p>
<p>如果我们更新 <code>foo</code> 和 <code>bar</code> 为使用读写内存屏障，代码如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    smp_wmb();</span><br><span class="line">    b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    smp_rmb();</span><br><span class="line">    assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个计算机系统的内存屏障更加复杂，但是通常来说，理解这3个变种就可以很好的介绍内存屏障了。</p>
<h1 id="内存屏障的顺序"><a href="#内存屏障的顺序" class="headerlink" title="内存屏障的顺序"></a>内存屏障的顺序</h1><p>这一节我们将呈现一些非常巧妙的内存屏障使用例子。有些使用技巧是通用的，而有些技巧在特定的CPU架构才有效，如果你的目标是设计通用的代码，就不要考虑特定CPU才支持的技巧。为了让我们更好的理解技巧，我们首先关注对违反顺序规则的架构（ordering-hostile architecture）。</p>
<h2 id="Ordering-Hostile-Architecture"><a href="#Ordering-Hostile-Architecture" class="headerlink" title="Ordering-Hostile Architecture"></a>Ordering-Hostile Architecture</h2><p>Ordering-Hostile 架构的计算机系统已经出现十年多，但是每种硬件系统对顺序的处理都有细微差别，要理解他们需要详细的了解具体的硬件架构。不应该让用户着迷特定硬件产生的技术规范，应该要设计比较通用的内存 Ordering-Hostile 系统架构。</p>
<p>我们设计的这套硬件支持如下排序规则：</p>
<ul>
<li>每个CPU都按照程序顺序规则访问内存。</li>
<li>CPU 会对带有 store 操作的指令重排序，仅且仅当两个操作引用了不同地址。</li>
<li>一个CPU的读内存屏障之前的 load 指令，能被其他CPU在执行这个读内存屏障后面的 load 指令之前感知到。这里说的是内存可见性，执行读内存屏障后面的 load 指令可定能看到执行此读内存屏障之前的 load 指令的内容。（书上原文是 <em>All of a given CPU’s loads preceding a read memory barrier (smp_rmb()) will be perceived by all CPUs to precede any loads following that read memory barrier</em>）。</li>
<li>一个CPU的写内存屏障之前的 store 指令，能被其他CPU在执行这个写内存屏障后面的 store 指令之前感知到。（书上原文是 <em>All of a given CPU’s stores preceding a write memory barrier (smp_wmb()) will be perceived by all CPUs to precede any stores following that write memory barrier.</em>）。</li>
<li>一个CPU的内存屏障之前的访问指令，能被其他CPU在执行这个写内存屏障后面的 访问指令之前感知到。</li>
</ul>
<p>想象一个大的 NUCA 系统（non-uniform cache architecture），为了给每个互联的 Node 节点提供公平的分配策略，每个 CPU 要一个队列，如图-9所示。尽管一个CPU在内存屏障下会按照顺序执行，但是在一组 Node 节点下的两个 CPU 依然会乱序执行。</p>
<p><img src="/images/memory_barrier_f9_example_ordering_hostile_architecture.jpg" alt="memory_barrier_f9_example_ordering_hostile_architecture" width="40%"></p>
<p><em>图-9 一种 Ordering-Hostile Architecture</em></p>
<p>下面来说说乱序的原因。</p>
<h2 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h2><p>图-10 是 3 个 CPU 并发执行三段代码的示意图。 <code>a</code>，<code>b</code>，<code>c</code>都初始化为0。</p>
<p><img src="/images/memory_barrier_list_c_1.jpg" alt="memory_barrer_list_c_1" width="60%"></p>
<p><em>图-10 代码示例1</em></p>
<p>假如CPU 0最近经历了大量的缓存失效，以致它的 message queue 是满的；而 CPU 1 一直处于独占缓存的情况下运行，以致它的 message queue 是空的。CPU 0 赋值给 <code>a</code> 和 <code>b</code> 将会立刻出现在 Node 0 的缓存（对 CPU 1 也是可见的），但是随后会被 CPU 0 之前缓存失效的大量动作所阻塞。相应的，CPU 1 赋值给 <code>c</code> 时会经历 CPU 1 之前的空 message queue，因此 CPU 2 可能看到 CPU 1 对 <code>c</code> 的赋值，而 CPU 0 对 <code>a</code> 的赋值此时 CPU 1 还看不到。最终导致断言失败。</p>
<h2 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h2><p>图-11 是 3个CPU并发执行三段代码的示意图。 <code>a</code>，<code>b</code> 都初始化为0。</p>
<p><img src="/images/memory_barrier_list_c_2.jpeg" alt="memory_barrier_list_c_2" width="60%"></p>
<p><em>图-11 代码示例2</em></p>
<p>假如CPU 0最近经历了大量的缓存失效，以致它的 message queue 是满的；而 CPU 1 一直处于独占缓存的情况下运行，以致它的 message queue 是空的。CPU 0 赋值给 <code>a</code> 将会立刻出现在 Node 0 的缓存（对 CPU 1 也是可见的），但是随后会被 CPU 0 之前缓存失效的大量动作所阻塞。CPU 1的对 <code>b</code> 赋值经历 CPU 1 之前的空 message queue。因此 CPU 2 可能会看到 CPU 1 对 <code>b</code> 的赋值，但是此时还看不到 CPU 0 对 <code>a</code> 的赋值。最终导致断言失败。</p>
<h2 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h2><p>图-13 是 3个CPU并发执行三段代码的示意图。 所有变量都初始化为0。</p>
<p><img src="/images/memory_barrier_list_c_3.jpg" alt="memory_barrier_list_c_3" width="60%"></p>
<p><em>图-12 代码示例3</em></p>
<p>注意，不管是 CPU 1 还是 CPU 2，都需要先看到 CPU 0 在第3行对 <code>b</code> 的赋值才能执行到第5行。一旦CPU 1 和CPU 2 执行到第4行的内存屏障，他们就都能够看到 CPU 0 在第2行内存屏障之前的所有赋值，当然就包括 <code>a</code>。同样的，CPU 0 在执行第9行的 <code>e</code> 赋值之前，也会一直等待 CPU 1 和 CPU 2 对 <code>c</code> 和 <code>d</code> 的赋值能够被自己看到，当 CPU 0 能指定到第8行时也说明 CPU 0 的对 <code>b</code> 的赋值已经被 CPU 1 和 CPU 2 可见。最后CPU 2断言会成功，因为它已经能看到 <code>a</code> 的值。</p>
<p>Linux 内核的 <code>synchronize_rcu()</code> 原语使用的就是此例类似的算法。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://stltqhs.github.io/2020/12/18/arch-why-mem-barrier/" title="计算机体系结构——为什么需要内存屏障" target="_blank" rel="external">https://stltqhs.github.io/2020/12/18/arch-why-mem-barrier/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/stltqhs" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/stltqhs" target="_blank"><span class="text-dark">海东青</span><small class="ml-1x">Java 技术专家</small></a></h3>
        <div>熟练 JVM、多线程、MySQL、容器化及云原生虚拟技术。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/12/21/distributed-dynamo/" title="分布式系列——Dynamo"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/12/18/arch-mem-alignment/" title="计算机体系结构——内存对齐原理"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   




   





    <script defer>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?be79fae6ef126e586106ff806c368fc7";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>



</body>
</html>